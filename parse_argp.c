/* SPDX-License-Identifier: GPL-2.0 */
/* Copyright (C) 2023 Qais Yousef */
#include <stdlib.h>

#include "parse_argp.h"

const char *argp_program_version = "sched-analyzer 0.1";
const char *argp_program_bug_address = "<qyousef@layalina.io>";

static char doc[] =
"Extract scheduer data using BPF and emit them into csv file or perfetto track events";

struct sa_opts sa_opts = {
	/* modes */
	.perfetto = true,
	.csv = false,
	/* perfetto opts */
	.system = true,
	.app = false,
	/* controls */
	.output = "sched-analyzer.perfetto-trace",
	.output_path = NULL,
	.max_size = 250 * 1024 * 1024, /* 250MiB */
	/* events */
	.util_avg_cpu = false,
	.util_avg_task = false,
	.util_avg_irq = false,
	.util_avg_rt = false,
	.util_avg_dl = false,
	.util_est_cpu = false,
	.util_est_task = false,
	.util_est_irq = false,
	.util_est_rt = false,
	.util_est_dl = false,
	.cpu_nr_running = false,
	.cpu_freq = false,
	.cpu_idle = false,
	.soft_irq = false,
	.sched_switch = false,
};

enum sa_opts_flags {
	OPT_DUMMY_START = 0x80,

	/* perfetto opts */
	OPT_SYSTEM,
	OPT_APP,

	/* controls */
	OPT_OUTPUT,
	OPT_OUTPUT_PATH,
	OPT_MAX_SIZE,

	/* events */
	OPT_UTIL_AVG,
	OPT_UTIL_AVG_CPU,
	OPT_UTIL_AVG_TASK,
	OPT_UTIL_AVG_IRQ,
	OPT_UTIL_AVG_RT,
	OPT_UTIL_AVG_DL,
	OPT_UTIL_EST,
	OPT_UTIL_EST_CPU,
	OPT_UTIL_EST_TASK,
	OPT_CPU_NR_RUNNING,
	OPT_CPU_FREQ,
	OPT_CPU_IDLE,
	OPT_SOFT_IRQ,
	OPT_SCHED_SWITCH,
};

static const struct argp_option options[] = {
	/* modes */
	{ "perfetto", 'p', 0, 0, "Emit perfetto track events and collect a trace. Requires traced and traced_probes to be running (default)." },
	{ "csv", 'c', 0, 0, "Produce CSV files of collected data." },
	/* perfetto opts */
	{ "system", OPT_SYSTEM, 0, 0, "[perfetto] Collect system wide data, requires traced and traced_probes to be running (default)." },
	{ "app", OPT_APP, 0, 0, "[perfetto] Collect only data generated by this app. Runs standalone without external dependencies on traced." },
	/* controls */
	{ "output", OPT_OUTPUT, "FILE", 0, "Filename of the perfetto-trace file to produce." },
	{ "output_path", OPT_OUTPUT_PATH, "PATH", 0, "Path to store perfetto-trace/csv file(s). PWD by default for perfetto and /tmp by default for csv." },
	{ "max_size", OPT_MAX_SIZE, "SIZE(KiB)", 0, "Maximum size of csv or perfetto file to produce, 250MiB by default." },
	/* events */
	{ "util_avg", OPT_UTIL_AVG, 0, 0, "Collect util_avg for CPU, tasks, irq, dl and rt." },
	{ "util_avg_cpu", OPT_UTIL_AVG_CPU, 0, 0, "Collect util_avg for CPU." },
	{ "util_avg_task", OPT_UTIL_AVG_TASK, 0, 0, "Collect util_avg for tasks." },
	{ "util_avg_irq", OPT_UTIL_AVG_IRQ, 0, 0, "Collect util_avg for irq." },
	{ "util_avg_rt", OPT_UTIL_AVG_RT, 0, 0, "Collect util_avg for rt." },
	{ "util_avg_dl", OPT_UTIL_AVG_DL, 0, 0, "Collect util_avg for dl." },
	{ "util_est", OPT_UTIL_EST, 0, 0, "Collect util_est for CPU and tasks." },
	{ "util_est_cpu", OPT_UTIL_EST_CPU, 0, 0, "Collect util_est for CPU." },
	{ "util_est_task", OPT_UTIL_EST_TASK, 0, 0, "Collect util_est for tasks." },
	{ "cpu_nr_running", OPT_CPU_NR_RUNNING, 0, 0, "Collect nr_running tasks for each CPU." },
	{ "cpu_freq", OPT_CPU_FREQ, 0, 0, "Collect cpu frequency changes, csv mode only." },
	{ "cpu_idle", OPT_CPU_IDLE, 0, 0, "Collect cpu idle changes, csv mode only." },
	{ "soft_irq", OPT_SOFT_IRQ, 0, 0, "Collect soft irq duration, csv mode only." },
	{ "sched_switch", OPT_SCHED_SWITCH, 0, 0, "Collect sched_switch events, csv mode only." },
	{ 0 },
};

static error_t parse_arg(int key, char *arg, struct argp_state *state)
{
	char *end_ptr;

	switch (key) {
	/* modes */
	case 'p':
		sa_opts.perfetto = true;
		sa_opts.csv = false;
		if (!sa_opts.output_path)
			sa_opts.output_path = ".";
		break;
	case 'c':
		sa_opts.perfetto = false;
		sa_opts.csv = true;
		if (!sa_opts.output_path)
			sa_opts.output_path = "/tmp";
		break;
	/* perfetto opts */
	case OPT_SYSTEM:
		sa_opts.system = true;
		sa_opts.app = false;
		break;
	case OPT_APP:
		sa_opts.system = false;
		sa_opts.app = true;
		break;
	/* controls */
	case OPT_OUTPUT:
		sa_opts.output = arg;
		break;
	case OPT_OUTPUT_PATH:
		sa_opts.output_path = arg;
		break;
	case OPT_MAX_SIZE:
		errno = 0;
		sa_opts.max_size = strtol(arg, &end_ptr, 0) * 1024;
		if (errno != 0) {
			perror("Unsupported max_size value\n");
			return errno;
		}
		if (end_ptr == arg) {
			fprintf(stderr, "max_size: no digits were found\n");
			argp_usage(state);
			return -EINVAL;
		}
		break;
	/* events */
	case OPT_UTIL_AVG:
		sa_opts.util_avg_cpu = true;
		sa_opts.util_avg_task = true;
		sa_opts.util_avg_irq = true;
		sa_opts.util_avg_rt = true;
		sa_opts.util_avg_dl = true;
		break;
	case OPT_UTIL_AVG_CPU:
		sa_opts.util_avg_cpu = true;
		break;
	case OPT_UTIL_AVG_TASK:
		sa_opts.util_avg_task = true;
		break;
	case OPT_UTIL_AVG_IRQ:
		sa_opts.util_avg_irq = true;
		break;
	case OPT_UTIL_AVG_RT:
		sa_opts.util_avg_rt = true;
		break;
	case OPT_UTIL_AVG_DL:
		sa_opts.util_avg_dl = true;
		break;
	case OPT_UTIL_EST:
		sa_opts.util_est_cpu = true;
		sa_opts.util_est_task = true;
		break;
	case OPT_UTIL_EST_CPU:
		sa_opts.util_est_cpu = true;
		break;
	case OPT_UTIL_EST_TASK:
		sa_opts.util_est_task = true;
		break;
	case OPT_CPU_NR_RUNNING:
		sa_opts.cpu_nr_running = true;
		break;
	case OPT_CPU_FREQ:
		sa_opts.cpu_freq = true;
		break;
	case OPT_CPU_IDLE:
		sa_opts.cpu_idle = true;
		break;
	case OPT_SOFT_IRQ:
		sa_opts.soft_irq = true;
		break;
	case OPT_SCHED_SWITCH:
		sa_opts.sched_switch = true;
		break;
	case ARGP_KEY_ARG:
		argp_usage(state);
		break;
	case ARGP_KEY_END:
		break;
	default:
		return ARGP_ERR_UNKNOWN;
	}

	return 0;
}

const struct argp argp = {
	.options = options,
	.parser = parse_arg,
	.doc = doc,
};
